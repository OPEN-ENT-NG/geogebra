import { Subject, Subscription } from "rxjs";
import { LightboxDelegate } from "./directives";
export interface INavigationInfo {
    accept(): void;
    reject(): void;
    confirmMessageKey?: string;
    checkGuardId?: string | "*";
}
export interface INavigationListener {
    onChange: Subject<INavigationInfo>;
    start(): void;
    stop(): void;
}
export interface INavigationGuard {
    reset(): void;
    canNavigate(): boolean;
    onUserConfirmNavigate?(canNavigate: boolean): void;
}
export declare const navigationGuardService: {
    debounceMs: number;
    _lastTime: any;
    _lastResponse: any;
    _listeners: Map<INavigationListener, Subscription>;
    _guards: Map<string, Set<INavigationGuard>>;
    _id_counter: number;
    onUserConfirmNavigate: ((canNavigate: boolean) => void)[];
    generateID(): string;
    _getGuardsMapByID(rootID: string): Set<INavigationGuard>;
    registerGuard(rootID: string, guard: INavigationGuard): void;
    unregisterGuard(rootID: string, guard: INavigationGuard): void;
    unregisterRoot(rootID: string): void;
    registerIndependantGuard(guard: INavigationGuard): string;
    unregisterIndependantGuard(guardID: string): void;
    registerListener(listener: INavigationListener): void;
    unregisterListener(listener: INavigationListener): void;
    tryNavigate(navigation: INavigationInfo): void;
    reset(rootID: string): void;
    resetAll(): void;
};
export declare class InputGuard<T> implements INavigationGuard {
    private currentValue;
    private resetter;
    private comparator;
    reference: T;
    constructor(currentValue: () => T, resetter: () => T, comparator?: (a: T, b: T) => boolean);
    unNaN(val: any): any;
    reset(): void;
    canNavigate(): boolean;
}
export interface IObjectGuardDelegate {
    guardObjectIsDirty(): boolean;
    guardObjectReset(): void;
    guardOnUserConfirmNavigate?(canNavigate: boolean): void;
}
export declare class ObjectGuard implements INavigationGuard {
    private currentValue;
    constructor(currentValue: () => IObjectGuardDelegate);
    reset(): void;
    canNavigate(): boolean;
    onUserConfirmNavigate(canNavigate: boolean): void;
}
export declare class AngularJSRouteChangeListener implements INavigationListener {
    private $rootScope;
    private static _instance;
    private subscription;
    onChange: Subject<INavigationInfo>;
    constructor($rootScope: any);
    start(): void;
    stop(): void;
    static getInstance($rootScope: any): AngularJSRouteChangeListener;
}
export declare class DOMRouteChangeListener implements INavigationListener {
    private static _instance;
    onChange: Subject<INavigationInfo>;
    private callback();
    private boundCallback;
    start(): void;
    stop(): void;
    static getInstance(): DOMRouteChangeListener;
}
export declare class TemplateRouteChangeListener implements INavigationListener {
    private static _instance;
    onChange: Subject<INavigationInfo>;
    private defaultTrigger;
    private containerNotTriggering;
    private containerTriggering;
    start(): void;
    stop(): void;
    setTriggerByDefault(trigger: boolean): void;
    private triggerNavigation(name);
    tryOpen(containerName: string, openCb: () => void, rejectCb: () => void): void;
    addIgnoreContainer(name: string): void;
    removeIgnoreContainer(name: string): void;
    addTriggerContainer(name: string): void;
    removeTriggerContainer(name: string): void;
    static getInstance(): TemplateRouteChangeListener;
}
export declare class ManualChangeListener implements INavigationListener {
    onChange: Subject<INavigationInfo>;
    start(): void;
    stop(): void;
}
export declare class LightboxChangeListener implements INavigationListener, LightboxDelegate {
    onChange: Subject<INavigationInfo>;
    start(): void;
    stop(): void;
    stayOpen(): Promise<boolean>;
}
