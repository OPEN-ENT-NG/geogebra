import { Model } from '../modelDefinitions';
import { Rights, Shareable } from '../rights';
import * as moment from 'moment';
import { Selectable, Eventer } from 'entcore-toolkit';
import { Document } from './workspace-v1';
export declare const MEDIALIB_APPNAME = "media-library";
export declare type TREE_NAME = "owner" | "shared" | "protected" | "public" | "trash" | "all" | "external";
export declare const FOLDER_TYPE = "folder";
export declare const FILE_TYPE = "file";
export declare class DocumentsListModel {
    private $filter;
    private _sort;
    incrementSize: number;
    private _displayNum;
    private _orderField;
    private _original;
    private _documents;
    constructor($filter: any, _sort?: boolean);
    protected recompute(): void;
    protected sort(): void;
    documents: Document[];
    orderField: string;
    displayNum: number;
    increment(): void;
    watch($scope: any, args?: {
        documents: string;
        orderFieldDocument?: string;
    }): DocumentsListModel;
}
export interface Node {
    _id?: string;
    children: Node[];
    name?: string;
}
export interface Tree extends Node {
    name: string;
    children: Element[];
    hidden?: boolean;
    filter?: TREE_NAME;
    hierarchical?: boolean;
    helpbox?: string;
    buttons?: {
        text: string;
        action: () => any;
        disabled: () => boolean;
        icon?: boolean;
        workflow?: string;
    }[];
    contextualButtons?: {
        text: string;
        action: () => any;
        allow?: () => boolean;
        right?: string;
    }[];
}
export interface Comment {
    id: string;
    author: string;
    authorName: string;
    comment: string;
    posted: boolean;
}
export interface Revision {
    _id?: string;
    documentId: string;
}
export declare type ContentTypeToRoleMapper = (contentType: string, previewRole: boolean) => string | undefined;
export declare type ElementToThumbMapper = (element: Element) => string | undefined;
export declare const ROLES: {
    IMG: string;
    HTML: string;
};
export declare enum ElementLoadStatus {
    Void = 0,
    Loading = 1,
    Loaded = 2,
}
export declare class CacheList<T> {
    private _ttlSeconds;
    private onChange;
    private shouldClear;
    private _reloadOnFail;
    private _nbTryOnFail;
    private _updatedAt;
    private _resetAt;
    private _data;
    private _timeout;
    private _status;
    private _nbTry;
    private _disabled;
    constructor(_ttlSeconds: number, onChange: (data: T[]) => void, shouldClear?: () => boolean, _reloadOnFail?: boolean, _nbTryOnFail?: number);
    readonly isEmpty: boolean;
    readonly isLoading: boolean;
    readonly isNotEmpty: boolean;
    readonly status: ElementLoadStatus;
    readonly ttlSeconds: number;
    readonly data: T[];
    readonly updatedAt: Date;
    readonly resetAt: Date;
    readonly disabled: boolean;
    add(data: T, matching?: (a: T, b: T) => boolean): void;
    remove(matching: (el: T) => boolean): void;
    reset(): void;
    disableCache(): void;
    setData(data: T[]): void;
    setAsyncData(data: Promise<T[]>): Promise<void>;
}
export declare class Element extends Model implements Node, Shareable, Selectable {
    static cacheConfiguration: {
        ttlFolderSeconds: number;
        ttlDocumentSeconds: number;
    };
    _id?: string;
    eType: string;
    eParent: string;
    name: string;
    title?: string;
    file?: string;
    deleted?: boolean;
    children: Element[];
    created: moment.Moment;
    trasher?: string;
    externalId?: string;
    _shared: any[];
    inheritedShares?: any[];
    _isShared: boolean;
    showComments?: boolean;
    editing?: boolean;
    revisions?: Revision[];
    comments?: Comment[];
    comment?: string;
    rights: Rights<Element>;
    ownerName?: string;
    owner: {
        userId: string;
        displayName: string;
    };
    uploadStatus?: "loading" | "loaded" | "failed" | "abort";
    uploadXhr?: XMLHttpRequest;
    hiddenBlob?: Blob;
    eventer: Eventer;
    ancestors: string[];
    newName?: string;
    newProperties?: {
        name?: string;
        legend?: string;
        alt?: string;
    };
    metadata?: {
        'content-type'?: string;
        role?: string;
        extension?: string;
        filename?: string;
        size?: number;
        captation?: boolean;
        duration?: number;
    };
    link?: string;
    icon?: string;
    version?: number;
    currentQuality?: number;
    application?: string;
    legend?: string;
    alt?: string;
    protected?: boolean;
    public?: boolean;
    cacheChildren: CacheList<Element>;
    cacheDocument: CacheList<Document>;
    constructor(data?: any);
    removeChild(matching: (el: Node) => boolean): void;
    addChild(el: Element): void;
    updateSelf(el: Element): void;
    updateChild(el: Element): void;
    removeDocument(matching: (el: Node) => boolean): void;
    addDocument(doc: Document): void;
    setChildren(elts: Element[]): void;
    clearChildren(): void;
    readonly isChildrenLoading: boolean;
    readonly isDocumentLoading: boolean;
    readonly isChildrenOrDocumentLoading: boolean;
    readonly isExternal: boolean;
    static createExternalFolder({externalId, name}: {
        name: string;
        externalId: string;
    }): Element;
    private static roleMappers;
    private static thumbMappers;
    static registerContentTypeToRoleMapper(mapper: ContentTypeToRoleMapper): void;
    static registerThumbUrlMapper(mapper: ElementToThumbMapper): void;
    readonly contentType: string;
    fromJSON(data: any): void;
    fromMe(): void;
    updateProps(): void;
    shared: any[];
    readonly canCopy: boolean;
    readonly canMove: boolean;
    readonly canWriteOnFolder: boolean;
    idEquals(id: string): boolean;
    idInList(ids: string[]): boolean;
    anyAncestors(ids: string[]): boolean;
    anyParent(ids: string[]): boolean;
    anySelf(ids: string[]): boolean;
    canCopyFileIdsInto(ids: string[]): boolean;
    resetNewProperties(): void;
    abortUpload(): void;
    fromFile(file: File | Blob): void;
    isShared: boolean;
    readonly isEditableImage: boolean;
    toJSON(): {
        _id: string;
        name: string;
        title: string;
        created: moment.Moment;
        eParent: string;
        eType: string;
        metadata: {
            'content-type'?: string;
            role?: string;
            extension?: string;
            filename?: string;
            size?: number;
            captation?: boolean;
            duration?: number;
        };
        version: number;
        link: string;
        icon: string;
        owner: {
            userId: string;
            displayName: string;
        };
        shared: any[];
    };
    role(): string;
    previewRole(): string;
    readonly thumbUrl: string;
    readonly documentUrl: string;
    readonly previewUrl: string;
    static role(fileType: string, previewRole?: boolean, extension?: string): string;
    readonly differentProperties: boolean;
    applyNewProperties(): void;
}
export declare class FolderContext {
    folder: Element;
    private originalDocuments;
    private filteredDocuments;
    private filteredFolders;
    private filtered;
    private sorted;
    private sortFunction;
    private cacheSortedDocuments;
    constructor(folder?: Element);
    private clearCache();
    setFolder(f: Element): void;
    setDocuments(c: Element[]): void;
    setFilter(all: Element[]): void;
    applyFilter(filter: (el: Element) => boolean): void;
    applySort(sort: (el1: Element, el2: Element) => number): void;
    pushDoc(el: Element): void;
    findDocuments(filter: (el: Element) => boolean): Element[];
    deleteDocuments(matching: (el: Element) => boolean): Element[];
    restore(): void;
    readonly documents: Element[];
    readonly folders: Element[];
    readonly all: Element[];
    readonly sortedDocuments: Element[];
    readonly sortedFolders: Element[];
    readonly sortedAll: Element[];
}
export declare function emptySharedFolder(): Element;
export declare function emptyFolder(): Element;
export declare function emptyDoc(): Element;
export declare function sortByCreatedAsc(): (doc1: Element, doc2: Element) => number;
export declare function sortByNameAsc(): (doc1: Element, doc2: Element) => number;
export declare function emptyNode(name?: string): Node;
export declare class ElementTree extends Element implements Tree {
    private tree;
    constructor(enableCache: boolean, tree: Tree);
    readonly hidden: boolean;
    readonly filter: TREE_NAME;
    readonly hierarchical: boolean;
    readonly helpbox: string;
    readonly buttons: {
        text: string;
        action: () => any;
        disabled: () => boolean;
        icon?: boolean;
        workflow?: string;
    }[];
    readonly contextualButtons: {
        text: string;
        action: () => any;
        allow?: () => boolean;
        right?: string;
    }[];
}
