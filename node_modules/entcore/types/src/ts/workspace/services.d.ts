import { PromiseHttp } from '../http';
import { Document } from './workspace-v1';
import * as workspaceModel from './model';
import { Subject } from 'rxjs';
export interface ElementQuery {
    id?: string;
    parentId?: string;
    hierarchical?: boolean;
    filter: workspaceModel.TREE_NAME;
    search?: string;
    includeall?: boolean;
    ancestorId?: string;
    application?: string;
    directShared?: boolean;
    limit?: number;
    skip?: number;
    onlyRoot?: boolean;
}
export interface WorkspaceEvent {
    action: "add" | "update" | "document-change" | "tree-change" | "delete" | "empty";
    treeSource?: workspaceModel.TREE_NAME;
    treeDest?: workspaceModel.TREE_NAME;
    dest?: workspaceModel.Element;
    elements?: workspaceModel.Element[];
    ids?: string[];
}
export declare type ElementWithVisible = workspaceModel.Element & {
    visibleGroups: Array<{
        id: string;
        name: string;
        structureName: string;
        groupDisplayName: string;
    }>;
    visibleUsers: Array<{
        id: string;
        username: string;
        lastName: string;
        firstName: string;
        login: string;
        profile: string;
    }>;
};
export interface WorkspacePreference {
    sortField?: string;
    sortDesc?: boolean;
    view?: WorkspacePreferenceView;
    bbmView?: WorkspacePreferenceView;
    quickstart?: "viewed" | "notviewed";
}
export declare type DocumentActionType = "comment" | "download" | "move" | "copy" | "share" | "history";
export declare type DocumentFilter = (element: workspaceModel.Element, query: ElementQuery) => boolean;
export declare type DocumentActionFilter = (element: workspaceModel.Element, type: DocumentActionType) => boolean;
export declare type FullScreenRenderer = (element: workspaceModel.Element) => {
    close();
} | false;
export declare type WorkspacePreferenceView = "list" | "icons" | "carousel";
export declare const workspaceService: {
    _externalFullScreen: FullScreenRenderer[];
    _externalActionFilter: DocumentActionFilter[];
    _externalDocumentFilters: DocumentFilter[];
    _externalFolders: Promise<workspaceModel.Element>[];
    _cacheFolders: workspaceModel.Element[];
    onChange: Subject<WorkspaceEvent>;
    onImportFiles: Subject<FileList>;
    onConfirmImport: Subject<workspaceModel.Element[]>;
    isLazyMode(): boolean;
    hasExternalFolders(): boolean;
    getExternalFolders(): Promise<workspaceModel.Element[]>;
    getExternalFolderFor({externalId}: {
        externalId: string;
    }): Promise<{
        exists: boolean;
        folder: workspaceModel.Element;
    }>;
    addExternalFolder(infoPromise: Promise<{
        externalId: string;
        name: string;
    }>): void;
    registerExternalDocumentFilter(filter: DocumentFilter): void;
    registerExternalActionFilter(filter: DocumentActionFilter): void;
    registerExternalFullScreenRenderer(renderer: FullScreenRenderer): void;
    renderFullScreen(element: workspaceModel.Element): false | {
        close(): any;
    };
    isActionAvailable(type: DocumentActionType, elts: workspaceModel.Element[]): boolean;
    getPreference(): Promise<WorkspacePreference>;
    savePreference(pref: WorkspacePreference): Promise<WorkspacePreference>;
    fetchFolders(params: ElementQuery, sort?: "name" | "created"): Promise<workspaceModel.Element[]>;
    fetchParentInfo(id: string): Promise<ElementWithVisible>;
    fetchTrees(params: ElementQuery, sort?: "name" | "created"): Promise<workspaceModel.Tree[]>;
    fetchDocuments(params: ElementQuery, sort?: "name" | "created", args?: {
        directlyShared: boolean;
    }): Promise<Document[]>;
    fetchChildren(parent: workspaceModel.Element, params: ElementQuery, sort?: "name" | "created", args?: {
        directlyShared?: boolean;
        onlyFolders?: boolean;
        onlyDocument?: boolean;
    }): Promise<Document[]>;
    fetchChildrenForRoot(tree: workspaceModel.ElementTree, params: ElementQuery, sort?: "name" | "created", args?: {
        directlyShared?: boolean;
        onlyFolders?: boolean;
        onlyDocument?: boolean;
    }): Promise<Document[]>;
    fetchFolderById(id: string): Promise<workspaceModel.Element>;
    countChildren(folder: workspaceModel.Element): number;
    totalFilesSize(fileList: FileList): number;
    isFile(el: workspaceModel.Element): boolean;
    isFolder(el: workspaceModel.Element): boolean;
    isInFoldersRecursively(folder: workspaceModel.Element, roots: workspaceModel.Node[]): boolean;
    restoreAll(elements: workspaceModel.Element[]): Promise<any>;
    removeAllFromList(toRemove: workspaceModel.Element[], list: workspaceModel.Element[]): workspaceModel.Element[];
    removeFromTree(tree: workspaceModel.Node, matching: (el: workspaceModel.Node) => boolean): void;
    trashAll(elements: workspaceModel.Element[]): Promise<any>;
    emptyTrash(): Promise<void>;
    rename(el: workspaceModel.Element, newNameOrigin: string): Promise<any>;
    deleteAll(elements: workspaceModel.Element[]): Promise<{
        nbFiles: number;
        nbFolders: number;
    }>;
    elementEqualsByRefOrId(el1: workspaceModel.Node, el2: workspaceModel.Node): boolean;
    sendComment(document: workspaceModel.Element): Promise<workspaceModel.Comment>;
    removeComment(document: workspaceModel.Element, comment: workspaceModel.Comment): Promise<any>;
    getAppropriateDataUnit(bytes: number): {
        nb: number;
        order: any;
    };
    formatDocumentSize(size: number): string;
    findFolderInTrees(trees: workspaceModel.Node[], folderId: string): workspaceModel.Element;
    updateInTree(trees: workspaceModel.ElementTree[], model: workspaceModel.Element): workspaceModel.Element;
    findParentFolderInTree(tree: workspaceModel.ElementTree, folderId: string): {
        parent: workspaceModel.Element;
        child: workspaceModel.Element;
    };
    findFolderInTree(tree: workspaceModel.Node, folderId: string): workspaceModel.Element;
    findFolderInTreeByRefOrId(container: workspaceModel.Node, child: workspaceModel.Node, listener?: (founded: any) => void): boolean;
    findElementInListByRefOrId(list: workspaceModel.Node[], child: workspaceModel.Node, listener?: (founded: any) => void): boolean;
    folderToString(tree: workspaceModel.Node, folder: workspaceModel.Element): string;
    downloadFiles(els: workspaceModel.Element[], includeDeleted?: boolean): void;
    moveAll(els: workspaceModel.Element[], dest: workspaceModel.Element): Promise<{
        nbFiles: number;
        nbFolders: number;
    }>;
    moveAllForShared(els: workspaceModel.Element[], dest: workspaceModel.Element): Promise<{
        nbFiles: number;
        nbFolders: number;
    }>;
    moveAllFromIds(ids: string[], dest: workspaceModel.Element): Promise<{
        nbFiles: number;
        nbFolders: number;
    }>;
    copyAll(els: workspaceModel.Element[], dest: workspaceModel.Element, sendEvent?: boolean): Promise<{
        copies: workspaceModel.Element[];
        nbFiles: number;
        nbFolders: number;
    }>;
    copyAllFromIds(ids: string[], dest: workspaceModel.Element): Promise<{
        copies: workspaceModel.Element[];
        nbFiles: number;
        nbFolders: number;
    }>;
    notifyContrib(folderId: string, eltsOrIds: string[] | workspaceModel.Element[], addVersion?: boolean): Promise<void> | PromiseHttp<{}>;
    createExternalDocument(file: File | Blob, document: Document, externalId: string, params?: {
        visibility?: "protected" | "public";
        application?: string;
    }): Promise<Document>;
    createDocument(file: File | Blob, document: Document, parent?: workspaceModel.Element, params?: {
        visibility?: "protected" | "public";
        application?: string;
    }): Promise<Document>;
    importZip(file: File | Blob, zip: Document, parent?: workspaceModel.Element, params?: {
        visibility?: "protected" | "public";
        application?: string;
    }): Promise<Document[]>;
    getDocumentBlob(id: string): Promise<Blob>;
    getPreviewBlob(id: string): Promise<Blob>;
    copyDocumentWithVisibility(source: workspaceModel.Element, args: {
        visibility: "protected" | "public";
        application: string;
    }, parent?: workspaceModel.Element): Promise<Document>;
    updateDocument(file: File | Blob, document: workspaceModel.Element): Promise<workspaceModel.Element>;
    createFolder(folder: workspaceModel.Element, parent?: workspaceModel.Element): Promise<workspaceModel.Element | {
        error?: string;
    }>;
    createFolders(folder: workspaceModel.Element, parents: workspaceModel.Element[]): Promise<any>;
    syncHistory(doc: workspaceModel.Element): Promise<workspaceModel.Element>;
    createRevision(file: string, doc: workspaceModel.Element, listener: (state: "error" | "pending" | "end", error?: string) => void): PromiseHttp<{}>;
    deleteRevision(rev: workspaceModel.Revision): Promise<any>;
    resetAllCache(tree: workspaceModel.Node, type: "document" | "folder" | "all", matching?: (el: workspaceModel.Node) => boolean): void;
};
